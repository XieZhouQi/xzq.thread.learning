# Lock(是一个接口)
是用来解决线程安全问题，与sychronized一样只是实现方式不一样

##ReentrantLock 实现原理

###猜想（如果自己去设计）
满足线程的互斥特性，同一时刻只有一个线程能访问（进入到加锁的代码中）-》多线程环境下，线程
的顺序访问

- 一定会涉及到锁的抢占，需要一个标记来实现互斥，全局变量（0，1）

- 抢占到的锁，怎么处理

- 	(不需要处理)
- 没有抢占道德锁，怎么处理

	
	- 需要等待（让处于排队中的线程，直接阻塞也就是释放CPU资源）
			
			- 如何让线程等待？
				- wait/notify
				- LockSupport.park/unpark(阻塞一个指定的线程，唤醒一个指定的线程)
				- Condition
			



- 需要排队（允许有N个线程被阻塞，此时线程处于活跃状态）
	
		- 通过一个数据结构，把这N个排队的线程存储起来

- 抢占到锁的释放处理，如何处理
	- LockSupport.unpark()-》唤醒处于队列中的指定线程


- 锁抢占的公平性（是否允许插队）
	
	1. 公平
	
	2. 非公平(默认非公平)


## AbstractQueuedSychronizer(AQS)

- 共享锁

- 互斥锁


## Condition